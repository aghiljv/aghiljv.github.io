__NUXT_JSONP__("/portfolio/Asset%20Bundle%20Server", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){return {data:[{post:{slug:h,name:h,titleImage:"assetBundleServer\u002Ftitle",briefdesc:j,technologies:"Unity 3D | Node JS | C#",toc:[],body:{type:"root",children:[{type:a,tag:"div",props:{},children:[{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:a,tag:e,props:{},children:[{type:b,value:"1. Technologies used"}]},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:"ol",props:{},children:[{type:b,value:f},{type:a,tag:i,props:{},children:[{type:b,value:"NodeJS"}]},{type:b,value:f},{type:a,tag:i,props:{},children:[{type:b,value:"Unity 3D"}]},{type:b,value:f},{type:a,tag:i,props:{},children:[{type:b,value:"C#"}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:a,tag:e,props:{},children:[{type:b,value:"2. Problem"}]},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:g,props:{},children:[{type:b,value:"\n  For a Unity HoloLens 2 project, the resuorces had a chance of being different\n  types, numbers and sizes according to the various factors. So, if I kept\n  everything within the application, it would still work. But the performance\n  and hence the user experience would be affected significantly. So I had to\n  find a way to make it all work without compromising the performance.\n"}]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:a,tag:e,props:{},children:[{type:b,value:"3. Challenges"}]},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:g,props:{},children:[{type:b,value:"\n  The solution was obvious. the resources should be kept in a server and\n  supplied to the application on-demand. The existing solution was to make use\n  of the existing cloud services. But that seemed like an overkill. Especially\n  when the required options were just to upload and download the resourses as\n  the user chooses. So, there was a need to create a small server that could be\n  hosted anywhere and could handle the upload and download request from the user\n  in a fast and efficient way.\n"}]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:a,tag:e,props:{},children:[{type:b,value:"4. Solution"}]},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:g,props:{},children:[{type:b,value:"\n  The required resources were categorised and set to be AssetBundles. A Node JS\n  server was created with upload function which would also replace the files if\n  the same are updated. The server would also help the unity application\n  download the resources which are asked by the application. A method was\n  created to upload the new AssetBundles to the server once it is created or\n  updated. The downloaded resources were kept in the device in a seperate\n  directory and the application would from then on will access the data from the\n  local device with no latency and would continue to do so as long as the file\n  is present. If the application cannot find the file, it would send the\n  download request to the server and download the same.\n"}]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:a,tag:e,props:{},children:[{type:b,value:"5. Result"}]},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:g,props:{},children:[{type:b,value:"\n  This application size reduced as most of the heavy resources now existed as a\n  seperate entity. The performance increases and latency was close to none.\n  There was complete control over the application and the server as it was made\n  in-house. Although, it was primarily designed to work with HoloLens 2, minor\n  changes would make it possible to use within any application built by unity.\n"}]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:a,tag:e,props:{},children:[{type:b,value:"6. Links"}]},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:g,props:{},children:[{type:b,value:"\n  The project was kept as two parts the server and the application."},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[]},{type:b,value:f},{type:a,tag:k,props:{href:"https:\u002F\u002Fgithub.com\u002Faghiljv\u002FassetBundleServer",style:l,target:m,rel:[n,o]},children:[{type:b,value:"Server"}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[]},{type:b,value:f},{type:a,tag:k,props:{href:"https:\u002F\u002Fgithub.com\u002Faghiljv\u002FUWPAssetBundle",style:l,target:m,rel:[n,o]},children:[{type:b,value:"Unity Application"}]},{type:a,tag:c,props:{},children:[]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:b,value:d},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[]},{type:b,value:d}]}]},dir:"\u002Fportfolios",path:"\u002Fportfolios\u002FAsset Bundle Server",extension:".md",createdAt:p,updatedAt:p},title:h,description:j,ogImage:"\u002Fimg\u002Fportfolio\u002FassetBundleServer\u002Ftitle.jpg",params:{slug:h}}],fetch:{},mutations:[["pageTitle\u002Fset","PORTFOLIO"]]}}("element","text","br","\n","b","\n  ","p","Asset Bundle Server","li","The project helps in creating and hosting AssetBundles while doing a resource demanding Unity project.","a","color: var(--primary-color)","_blank","noopener","noreferrer","2022-12-24T07:45:17.618Z")));