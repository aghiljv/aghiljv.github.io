__NUXT_JSONP__("/blog/How%20to%20be%20an%20effective%20Engineer", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){return {data:[{blog:{slug:k,name:l,titleImage:"280920\u002FeeTitle",briefdesc:m,postDate:"September 28, 2020",blogNumber:26,toc:[{depth:2,text:n}],body:{type:"root",children:[{type:b,tag:e,props:{},children:[{type:a,value:"\n  Every software engineer or developer might have asked this question to\n  themselves or to their colleagues at some point. How to make myself better as\n  an engineer or developer? If you haven’t, you should.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  The answers would differ from person to person. Some might even go very\n  specific. But there are somethings that so many agree upon which could be\n  applied by pretty much every one in the industry.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"1. Analysis of scenarios"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:g,props:{style:h,src:"\u002Fimg\u002Fblog\u002F280920\u002Fanalysis.jpg",alt:"Analysis of scenarios"},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  The ability to consider many different scenarios is a must have trait for any\n  good engineer. This applies both to the internal and external events that can\n  occur as well as the logic in the program. Asking the following questions\n  might help us discover what types of events the software needs to handle.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:o,props:{style:p},children:[{type:a,value:i},{type:b,tag:j,props:{},children:[{type:a,value:"What if this queue becomes full?"}]},{type:a,value:i},{type:b,tag:j,props:{},children:[{type:a,value:"What if other server restarts while this server is restarting?"}]},{type:a,value:i},{type:b,tag:j,props:{},children:[{type:a,value:"What if there is no response to this request?"}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Also, the following questions might help us find the different paths in the\n  logic.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:o,props:{style:p},children:[{type:a,value:i},{type:b,tag:j,props:{},children:[{type:a,value:"What if none of these arguments are true?"}]},{type:a,value:i},{type:b,tag:j,props:{},children:[{type:a,value:"What happens if the argument is null? Etc."}]},{type:a,value:c}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"2. Problem Decomposition"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:g,props:{style:h,src:"\u002Fimg\u002Fblog\u002F280920\u002Fproblem.jpg",alt:"Problem Decomposition"},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Software is primarily about solving problems. So, before we start writing\n  code, we need to be clear on how to solve the problem. The ability to break\n  down a problem into smaller chunks is a formidable weapon in any engineer’s\n  arsenal. But it doesn’t stop there. We should be able to model the problem in\n  such a way that the resulting program is easy to reason about, easy to\n  implement and test.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"3. Naming"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:g,props:{style:h,src:"\u002Fimg\u002Fblog\u002F280920\u002Fnaming.jpg",alt:"Naming"},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Properly naming classes, methods, functions and variables goes a long way.\n  When done well, the software becomes self-documenting. That is, the function\n  of the code is quite clear just from reading the source code. Self-documenting\n  codes naturally leads to smaller methods, rather than a few large ones, simply\n  because we get more places to put meaningful names.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Naming things is not easy as it sounds. It needs to be clear in our mind what\n  each name represents. Sometimes that might change during the development\n  process. That is why renaming is just as important as naming.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"4. Consistency"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:g,props:{style:h,src:"\u002Fimg\u002Fblog\u002F280920\u002Fconsistency.jpg",alt:"Consistency"},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Managing complexity is undoubtedly one of the biggest challenges in software\n  development. Consistency is key here. It reduces some of the complexity by\n  allowing us to see patterns and infer how things are named, used and handled.\n  We do not require to use much brain power to remember exceptions and random\n  variations, with consistency. Consistency applies to variable names and\n  grouping, method naming, the division into modules, directory structure,\n  documentation, the GUI, logging, error-handling etc. For instance, if some\n  variables are related and appear together, try to use them in the same order.\n  This will make it easier to see if any goes missing or if they have been mixed\n  up. There is a high chance for inconsistencies while modifying a software.\n  Good engineers always ensure that even the small parts are right and the\n  consistency is kept while modification.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"5. Learning"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:g,props:{style:h,src:"\u002Fimg\u002Fblog\u002F280920\u002Flearning.jpg",alt:"Learning"},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  We are constantly learning as a software engineer. We have to understand what\n  a feature is supposed to do before adding it. It goes without saying prior to\n  that we must understand what the existing code does. It will make the addition\n  of the new feature that much simpler. We also have to learn about the\n  surrounding systems in order to interface with them appropriately. Obviously,\n  the ability to learn fast will make us more effective, but not necessarily\n  always.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c}]},{type:b,tag:"h2",props:{},children:[{type:a,value:n}]},{type:a,value:c},{type:b,tag:e,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Disclaimer : The views and opinions expressed in the article belong solely to the\n  author, and not necessarily to the author's employer, organisation, committee\n  or other group or individual.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:d,props:{},children:[]},{type:b,tag:d,props:{},children:[]}]},dir:"\u002Fblogs",path:"\u002Fblogs\u002FHow to be an effective Engineer",extension:".md",createdAt:q,updatedAt:q},title:l,description:m,ogImage:"\u002Fimg\u002Fblog\u002F280920\u002FeeTitle.jpg",params:{slug:k}}],fetch:{},mutations:[["pageTitle\u002Fset","BLOG"]]}}("text","element","\n","br","p","b","img","width: 100%","\n  ","li","How to be an effective Engineer","How to be an effective Engineer?","The necessary skills needed for any software engineer.","If we have these skills, we can learn new languages and tools much quicker\n  and create exceptional software.","ul","list-style-position: inside","2022-12-24T07:45:17.608Z")));