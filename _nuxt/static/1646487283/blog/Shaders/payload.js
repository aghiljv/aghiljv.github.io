__NUXT_JSONP__("/blog/Shaders", (function(a,b,c,d,e,f,g,h,i){return {data:[{blog:{name:g,titleImage:"080221\u002Ftitle",briefdesc:h,postDate:"February 07, 2021",toc:[{depth:2,text:i}],body:{type:"root",children:[{type:b,tag:e,props:{},children:[{type:a,value:"\n  A shader is a program used to render different pixels. Shaders are used when\n  detailing shadows, lighting, texture gradients and more. However, they can do\n  a lot more than just their namesake. You can often see shaders being packaged\n  as mods for games, transforming the dull, pixelated games into stunning,\n  sun-soaked landscapes.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Shader is a set of instructions that runs on the GPU (Graphics Processing\n  Unit). GPU is a processing unit or a circuit, specially designed for faster\n  and efficient computer graphics operation or image manipulation.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Shaders are categorised based on their functionality.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"Vertex Shader"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Vertex shader transforms each vertex's 3D position in virtual space to the 2D\n  coordinate at which it appears on the screen (as well as a depth value for the\n  Z-buffer). Vertex shaders can manipulate properties such as position, colour\n  and texture coordinates, but cannot create new vertices. The output of the\n  vertex shader goes to the next stage in the pipeline, which is either a\n  geometry shader if present, or the rasterizer. Vertex shaders can enable\n  powerful control over the details of position, movement, lighting, and colour\n  in any scene involving 3D models.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"Pixel Shader"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Pixel shaders, also known as fragment shaders, compute colour and other\n  attributes of each \"fragment\"- a unit of rendering work affecting at most a\n  single output pixel. The simplest kinds of pixel shaders output one screen\n  pixel as a colour value. More complex shaders with multiple inputs\u002Foutputs are\n  also possible. Pixel shaders range from simply always outputting the same\n  colour, to applying a lighting value, to doing bump mapping, shadows, specular\n  highlights, translucency and other phenomena.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"Tessellation Shader"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  As of OpenGL 4.0 and Direct3D 11, a new shader class called a tessellation\n  shader has been added. It adds two new shader stages to the traditional model-\n  tessellation control shaders (also known as hull shaders) and tessellation\n  evaluation shaders (also known as Domain Shaders), which together allow for\n  simpler meshes to be subdivided into finer meshes at run-time according to a\n  mathematical function. The function can be related to a variety of variables,\n  most notably the distance from the viewing camera to allow active\n  level-of-detail scaling. This allows objects close to the camera to have fine\n  detail, while further away ones can have coarser meshes, yet seem comparable\n  in quality. It also can drastically reduce required mesh bandwidth by allowing\n  meshes to be refined once inside the shader units instead of down-sampling\n  very complex ones from memory.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"Geometry Shader"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  The geometry shader is responsible for the creation of new rendering\n  primitives parting from the output of the vertex shader. A geometry shader is\n  executed once per primitive, which is, in the worst case (when it is used to\n  emit point primitives), the same as the vertex shader. The best-case scenario\n  is when it is used to emit triangles, because only then will it be executed\n  three times less than the vertex shader, but this complexity is relative.\n  Although the geometry shader's execution could be cheap, it always increases\n  the scene's complexity, and that always translates into more computational\n  time spent by the GPU to render the scene.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:f,props:{},children:[{type:a,value:"Compute Shader"}]},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  The compute shader is a general-purpose shader that is used outside of a\n  rendering pipeline. That means they are not used to draw a primitive or to\n  shade a pixel. They are used for using GPUs parallel processing capability for\n  general-purpose tasks. Additional stages in animation or lighting algorithms\n  can be examples of compute shaders.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:c}]},{type:b,tag:"h2",props:{},children:[{type:a,value:i}]},{type:a,value:c},{type:b,tag:e,props:{},children:[]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:a,value:c},{type:b,tag:e,props:{},children:[{type:a,value:"\n  Disclaimer : The views and opinions expressed in the article belong solely to\n  the author, and not necessarily to the author's employer, organisation,\n  committee or other group or individual.\n"}]},{type:a,value:c},{type:b,tag:d,props:{},children:[]},{type:b,tag:d,props:{},children:[]},{type:b,tag:d,props:{},children:[]}]},dir:"\u002Fblogs",path:"\u002Fblogs\u002FShaders",extension:".md",slug:g,createdAt:"2021-02-07T04:53:50.404Z",updatedAt:"2021-02-07T05:04:23.107Z"},title:g,description:h,ogImage:"\u002Fimg\u002Fblog\u002F080221\u002Ftitle.jpg",params:{slug:g}}],fetch:{},mutations:[["pageTitle\u002Fset","BLOG"]]}}("text","element","\n","br","p","b","Shaders","Why do we need shaders and what types of shaders are out there.","Shaders transform dull and dreary environments that may have lacked a\n  cohesive look to staggeringly beautiful works of art.\n")));